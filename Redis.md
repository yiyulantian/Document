描述：
k-v缓存，用于存储数据，虽然是在内存中，但和本地缓存还是有差别的，可以看出数据在内存中的数据库；单线程，复用IO；因为是单线程，所以所有并发命令其实都会被串行执行，相对于分布式存储系统，简单很多，应用起来也清晰便捷，因为redis本身没有锁的概念；

与memcache区别：
memcache只支持存储string数据；而redis的支持更多的数据结构
memcache只多线程的，非阻塞IO复用，比redis单线程从IO方面来说要快，在高并发场景下，memcache更优秀，因为多线程处理时可以更好的利用IO资源
memcache不支持持久化，这是为了把性能发挥到极致
综上，如果确定业务只用来存储string数据，且不要求过高的持久性，可以用memcache提高性能。其他情况都建议使用redis

常用命令：
get、set、decr、incr、mget
hset、hget、hgetall
list l/rpush l/rpopl/rpop lrange这是个双向链表
set 集合 可排重 ，也可 sorted set 有排序

内存释放策略
如果redis存储数据过多，超出了内存限制，就需要删除一些数据，那删除的策略有三种：
从设置过期时间的数据删除：按照过期时间，删除快过期的（ttl）；按照使用频率，删除最近最少使用的（lru）；随机删除（random）
从所有数据中删除：lru和random
不删除

并发竞争（锁）
redis单线程，所有操作都会被串行化，所以redis本身没有锁的概念，使用redis出现脏数据，不可重复读等问题都是客户端并发使用时，无法控制资源的读写顺序造成的；为了避免这些情况：
从客户端看，要有连接池来管理连接，对写操作可以使用锁；
从服务器看，对于抢占式的资源使用setnx，只能写一次
redlock

事务
redis本身支持的事务是一个假事务，只是支持了一批命令顺序指向，同个watch可以监听到在哪一步失败了，但不会回滚之前的操作，更不会锁主操作的资源

pipeline
可以将多个命令一次发送到redis；这样减少每次的网络耗时，每往pipeline中方一个操作，都会拿到一个结果对象，在一次传输后，可通过对象中的方法得到该命令的结果；因此可以通过对象操作，实现传输后是阻塞还是非阻塞；适用于批量操作某些资源，但资源间不需要抢占的场景

持久化
redis的持久化方式有两种：
AOF，类似数据库的blog，记录每次操作的数据，将操作数据追加到AOF文件中，因此会越来越大；包含的数据细节多，但不方便数据恢复
RDB，每个一段时间将数据备份，只存最终数据结果，所有包含的数据细节不多，但不会随着时间变大（如果redis本身数据量不变的话），恢复起来也方便；
触发RDB文件更新：
1.在指定时间间隔，执行写操作次数>配置数据（60，10000 60秒执行10000次  || 90，1 90秒内1个操作（默认配置））
2.执行了save命令或bgsave
3.flushall，会清空所有redis 数据，并持久化，所以flushall命令是不能恢复的
4.shutdown，关程序前，备份
由此可见，rdb，虽然方便，但不一定准；且虽然文件下，但恢复时，很耗性能和内存
AOF默认是不开的，打开可以设置为每个操作都写或每秒写一次，这样就有效的避免了RDB的缺陷，数据有很高的完整性保证；AOF文件也不会一直大下去，到一定规模，redis会将该文件中的老数据归档压缩

与消息队列：
redis在设计之初就不是用来做消息队列的。但由于其提供了list的数据结构和Pub/Sub命令，让很多人用redis做消息队列；但redis并没能支持消息队列的很多功能；虽然可以用来push和pop，拥有消息队列的基础功能（生产和消费）；但还有很多东西要考虑：
写的太快，读太慢，大量数据挤压在内存中怎么办？
数据的可靠性怎么保重？redis宕机
没有消息状态，读完就没了，ack也没有，消费失败怎么办
这些虽然可以通过业务代码弥补，但毕竟不是redis提供的功能，无论是可用性和稳定性上都无法保证
redis作者写了一个disque的项目，来帮助想用redis做消息队列的人😂