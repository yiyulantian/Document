mysql

数据库+数据库实例：数据库只是数据库文件，而数据库实例是用来操作数据库文件的上层接口

mysql的架构：
1.链接管理（链接池）、线程管理
2.sql的解析，分析，优化，缓存，存储过程，触发器，视图等
3.数据存储，提取的数据引擎（innodb，MyISAM）
4.数据库存储文件


innodb：
存储：
所有数据，在逻辑上按表空间存放，表空间内分段，区，页三个单位粒度
页的大小默认是16K，但是可以设置，随着设置的不同，每个分区表的数量也会变化；一个分区最少要1M，页最少要有64个（两者没有必然关系）
实际的物理存储：表的定义放在frm文件，表中的数据和索引等放在idb里
页是innodb的最小磁盘管理粒度，按行存储，以16K大小的页要被存放2-200行记录
mysql5.7后innodb有多种数据行的记录格式，各有差异
如上所说，每个页都是固定大小的，如果一行数据的大小太大，不适合全部记录在页记录中，而会采用行溢出数据存储方式，将数据的放在溢出页，在页数据中只存如指向溢出页的指针
页的结构：七部分（1-7），1和7在头尾，两个haeder记录页的头信息；2和6在次头尾，两个页面信息集合包括页面内数据行的稀疏索引；3中记录两个值（最大/最小记录值）；4中是用户存储数据；5是空闲空间，是一个链表接口，方便数据的增删，所以整个页存储的数据是无序的；查找时B+ tree不会直接查到记录行，而只能定位到页，将整个页读到内存中，再通过页结构中存储的稀疏索引定位到最终行

索引：
聚集索引：按照表中的主键，顺序构造构造B+ tree，叶子节点直接放数据行的全部数据，一个表只能有一个聚集索引（一般都是主键），和物理存储方式关系密切，是根据实际的存储结构生成的
辅助索引：不是聚集索引的索引都是辅助索引，一个表里可以有多个，只是为了加速查找，不会包含所有行数据，只有索引各列和一个指向该行的主键


锁：
乐观锁：不是真的锁，是一种思想，就是先尝试修改数据，然后回写时判断有没有被改过，如果被改了就回滚或重试，如果没有被改，就持久化
悲观锁：是真的锁，使用算法、机制来控制并发情况下的资源安全性
所有锁，包括乐观锁，都是对冲突概率，重试成本，并发大小，响应速度的多方平衡、协调的

悲观锁中分共享锁和互斥锁，也就是读锁和写锁，这个粒度是针对行的；针对表的有意向共享锁和意向互斥锁，意向锁的存在只是为了快速知道是否有人锁定了表中的某行数据；如果没有，需要检查表中所有数据行是否存在互斥锁；而现在只需要在加行互斥锁时，顺便加上意向互斥锁就可以了；因此行互斥锁是与所有锁互斥的，而意向互斥锁则不是，可以重复加

锁算法（锁方式）：

recode lock 记录锁
Gap lock 间隙锁
next-key lock 记录锁+间隙锁
有锁就可能形成死锁

事务：
事务有ACID原则：原子性，一致性，隔离性，持久性
隔离级别：
read uncommited 不提交读，也就是不加锁；事务不提交，就能读到修改的数据，也就是可能读到脏数据
read comminted  提交读，加行锁，不加间隙锁；事务提交后，才能读取，事务前后两次读取数据不一致，也就是不可重复读（un repeatable read）
repeatable read 可重复读；多次读，读到的数据为第一次读时的快照，但会有幻读情况
serializable read 所有读都加共享锁，也就是锁表，这样不存在幻读情况

以上的隔离级别是指多个事务间相互隔离的程度；隔离级别越高，事务间影响越小，数据越安全准确，但是并发性越低；
不同级别的影响（依次对应上面前三种级别，最后一种会锁表，因此不存在任何问题）：
脏读：事务A还没提交时，另一个事务B可以读到未提交的数据，该数据存在不确定性，万一A回滚了，那么事务B中使用的数据就是脏数据
不可重复读：事务A先后两次读取同一个数据，但在两次间事务B对该数据进行了修改，那么A事务内，没有对数据进行任何修改，但两次读取的数据却不一致
幻读：事务A中对一批数据进行操作，同时事务B插入（删除也行）了一条满足事务A条件的数据，那么当两个事务提交后，会发现事务A并没有将所有满足条件的数据进行修改（因为有条新数据是事务B插入的，在事务A中不可见）

mysql默认使用的是repeatable read级别的隔离；可重复读：事务A先后两次两次读取同一数据，但在两次间事务B对数据进行了修改，这是事务A两次读取数据一致（读的时候不更新版本号），如果A中存在写操作，只需要更新版本号，使取到的数据为最新，就不会出现数据不一致问题，基本解决了我们日常事务操作中的问题；但是没有解决幻读。幻读和不可重复读很像，不好理解；不可重复读一般是更改数据（针对某一行或某些行），幻读一般是插入或删除数据（角度是整张表，也就是说彻底解决幻读，就要读写全锁表）；mysql的可重复度级别具体实现是如果事务操作中有主键索引，那么就用next-key算法，将操作行和附近行都锁了；如果没有主键索引就直接锁表；使得事务间不能同时操作通一块间隙记录，可以很大程度上避免幻读；


